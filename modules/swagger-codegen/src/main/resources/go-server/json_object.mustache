package helpers

/**
* Generated automatically from swagger-codegen. Don't edit here! There's no point :)
**/


import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"log"
	"os"
	"strconv"
    "github.com/gorilla/mux"
)

const (
	DB               = "test"
	PUSH_TOKEN_TABLE = "push_token"
	USER_TABLE       = "user"
)

var (
	Trace   *log.Logger
	Info    *log.Logger
	Warning *log.Logger
	Error   *log.Logger
)

func initLog( traceHandle io.Writer, infoHandle io.Writer, warningHandle io.Writer, errorHandle io.Writer) {

	Trace = log.New(traceHandle,
		"TRACE: ",
		log.Ldate | log.Ltime | log.Lmicroseconds | log.Lshortfile)

	Info = log.New(infoHandle,
		"INFO: ",
		log.Ldate | log.Ltime | log.Lshortfile)

	Warning = log.New(warningHandle,
		"WARNING: ",
		log.Ldate | log.Ltime | log.Lshortfile)

	Error = log.New(errorHandle,
		"ERROR: ",
		log.Ldate | log.Ltime | log.Lshortfile)
}

func init() {
	initLog(os.Stdout, os.Stdout, os.Stdout, os.Stderr)
}

func SendClientCreatedOKResult(w http.ResponseWriter, request *http.Request, message string) {
	SendClientCreatedJsonStringResult(w, request, fmt.Sprintf("{\"message\":\"%s\"}", message))
}

func SendClientCreatedOKObject(w http.ResponseWriter, request *http.Request, obj interface{}) {
	response, err := json.Marshal(obj)
	if err != nil {
		SendClientErrorInternalServerErrorResult(w, request, err)
	} else {
		SendClientCreatedJsonStringResult(w, request, string(response))
	}
}

func SendClientOKObject(w http.ResponseWriter, request *http.Request, obj interface{}) {
	response, err := json.MarshalIndent(obj,"","   ")
	if err != nil {
		SendClientErrorInternalServerErrorResult(w, request, err)
	} else {
		SendClientOKJsonResult(w, request, string(response))
	}
}

func SendClientCreatedJsonStringResult(w http.ResponseWriter, request *http.Request, message string) {
	w.WriteHeader(http.StatusCreated)
	w.Header().Set("Content-Type", "application/json")
	io.WriteString(w, message)
}

func SendClientOKJsonResult(w http.ResponseWriter, request *http.Request, message string) {
	w.WriteHeader(http.StatusOK)
	w.Header().Set("Content-Type", "application/json")
	io.WriteString(w, message)
}

func SendClientOKMessageResult(w http.ResponseWriter, request *http.Request, message string) {
	SendClientOKObject(w, request, map[string]string{"response":"ok","message":message})
}

func SendClientErrorBadRequestError(w http.ResponseWriter, request *http.Request, error error) {
	Info.Println("BAD Request:[" + request.Method + "]{" + request.URL.Path + "}?" + request.URL.RawQuery )
	SendClientJsonObject(w, request, http.StatusBadRequest,  map[string]string{"response":"ok","message":error.Error()})
}

func SendClientErrorBadRequestMessage(w http.ResponseWriter, request *http.Request, message string) {
	SendClientJsonObject(w, request, http.StatusBadRequest,  map[string]string{"response":"ok","message":message})
}

func SendClientErrorUnauthorizedResult(w http.ResponseWriter, request *http.Request, error_message string) {
	SendClientJsonObject(w, request, http.StatusUnauthorized,  map[string]string{"response":"ok","message":error_message})
}

func SendClientErrorNotAcceptableResult(w http.ResponseWriter, request *http.Request, error_message string) {
	SendClientJsonObject(w, request, http.StatusNotAcceptable,  map[string]string{"response":"ok","message":error_message})
}

func SendClientErrorNotFoundResult(w http.ResponseWriter, request *http.Request, message string) {
	SendClientJsonObject(w, request, http.StatusNotFound, message)
}

// An unexpceted error
func SendClientErrorInternalServerErrorResult(w http.ResponseWriter, request *http.Request, error_message error) {
	//err := errors.Wrap(error_message, 1)
	//log.Println("Unexpected Error: Request:[" + request.Method + "]{" + request.URL.Path + "}?" + request.URL.RawQuery )
	//log.Println(err.ErrorStack())
	SendClientJsonObject(w, request, http.StatusInternalServerError, error_message.Error())
}

func sendClientErrorEmptyBodyResult(w http.ResponseWriter, request *http.Request, http_code int) {
	Info.Printf("ERROR EMPTY BODY RESONSE: %d\n", http_code)
	w.WriteHeader(http_code)
	w.Header().Set("Content-Type", "application/json")
}

func SendClientJsonObject(w http.ResponseWriter, request *http.Request, http_code int, obj interface{}) {
    w.Header().Set("Content-Type", "application/json")
    if response, new_object_err := json.Marshal(obj);new_object_err != nil {
        w.WriteHeader(500)
        w.Write(response)
    } else {
        w.WriteHeader(http_code)
        w.Write(response)
    }
}

func NewHttpAPIError( error_code int, message string ) error{
	return &HttpAPIError{error_code,message,nil}
}
func NewHttpAPIErrorBadRequest( message string ) error {
	return &HttpAPIError{http.StatusBadRequest,message,nil}
}
func NewHttpAPIErrorForbidden( message string ) error {
	return &HttpAPIError{http.StatusForbidden,message,nil}
}
func NewHttpAPIErrorNotAcceptable( message string ) error {
	return &HttpAPIError{http.StatusNotAcceptable,message,nil}
}
func NewHttpAPIErrorUnauthorised( message string ) error {
	return &HttpAPIError{http.StatusUnauthorized,message,nil}
}
func NewHttpAPIErrorNotFound( message string ) error {
	return &HttpAPIError{http.StatusNotFound,message,nil}
}

func NewHttpAPIInternalErrorMessage( error string) error{
	return &HttpAPIError{http.StatusInternalServerError,error,nil}
}

func NewHttpAPIInternalError( error error ) error{
	return &HttpAPIError{http.StatusInternalServerError,"",error}
}

type HttpAPIError struct {
	ErrorCode int `json:"error_code"`
	ErrorMessage string `json:"error_message"`
	ErrorObject error `json:"error"`
}

type HttpAPIResponse struct {
	Message string `json:"message"`
}

func (e HttpAPIError) Error() string {
	return fmt.Sprintf("%s (%d)", e.ErrorMessage, e.ErrorCode)
}

func CanHaveGetInt(w http.ResponseWriter, r *http.Request, param string) (int, bool, bool) {
	menu_item_id_s := r.URL.Query().Get(param)
	if len(menu_item_id_s) == 0 {
		return 0, false, true
	}else {
		group_id, group_conv_err := strconv.Atoi(menu_item_id_s)
		if group_conv_err != nil {
			SendClientErrorBadRequestMessage(w, r, "Illegal " + param)
			return 0, true, false
		}
		return group_id, true, true
	}
}

func MustHaveGetInt(w http.ResponseWriter, r *http.Request, param string) (int64, bool) {
	menu_item_id_s := r.URL.Query().Get(param)

    if len(menu_item_id_s)==0 {
        vars := mux.Vars(r)
        menu_item_id_s = vars[param]
    }

	if len(menu_item_id_s) == 0 {
		SendClientErrorBadRequestMessage(w, r, "Missing " + param)
		return 0, false
	}else {
		group_id, group_conv_err := strconv.ParseInt(menu_item_id_s,10,0)
		if group_conv_err != nil {
			SendClientErrorBadRequestMessage(w, r, "Illegal " + param)
			return 0, false
		} else if group_id == 0 {
			SendClientErrorBadRequestMessage(w, r, "Illegal " + param)
			return 0, false
		}
		return group_id, true
	}
}

func MightHaveGetInt(r *http.Request, param string) (int64, bool, error) {
	menu_item_id_s := r.URL.Query().Get(param)

    if len(menu_item_id_s)==0 {
        vars := mux.Vars(r)
        menu_item_id_s = vars[param]
    }

	if len(menu_item_id_s) == 0 {
		return 0, false, nil
	}else {
		group_id, group_conv_err := strconv.ParseInt(menu_item_id_s,10,0)
		if group_conv_err != nil {
			return 0, true, NewHttpAPIErrorBadRequest("Illegal " + param)
		}
		return group_id, true, nil
	}
}

func MustHaveGetString(w http.ResponseWriter, r *http.Request, param string) (string, bool) {
	menu_item_id_s := r.URL.Query().Get(param)
	if len(menu_item_id_s) == 0 {
        vars := mux.Vars(r)
        menu_item_id_s = vars[param]

		if len(menu_item_id_s) == 0 {
			SendClientErrorBadRequestMessage(w, r, "Missing " + param)
			return "", false
		}
	}
	return menu_item_id_s, true
}

func MightHaveGetString(r *http.Request, param string) (string, bool) {
	menu_item_id_s := r.URL.Query().Get(param)

    if len(menu_item_id_s)==0 {
        vars := mux.Vars(r)
        menu_item_id_s = vars[param]
    }

	if len(menu_item_id_s) == 0 {
		return "", false
	}else {
		return menu_item_id_s, true
	}
}
