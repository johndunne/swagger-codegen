package helpers

/**
* Generated automatically from swagger-codegen. Don't edit here! There's no point :)
**/


import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"log"
	"os"
	"strconv"
    "github.com/gorilla/mux"
)

const (
	DB               = "test"
	PUSH_TOKEN_TABLE = "push_token"
	USER_TABLE       = "user"
)

var (
	Trace   *log.Logger
	Info    *log.Logger
	Warning *log.Logger
	Error   *log.Logger
)

func initLog( traceHandle io.Writer, infoHandle io.Writer, warningHandle io.Writer, errorHandle io.Writer) {

	Trace = log.New(traceHandle,
		"TRACE: ",
		log.Ldate | log.Ltime | log.Lmicroseconds | log.Lshortfile)

	Info = log.New(infoHandle,
		"INFO: ",
		log.Ldate | log.Ltime | log.Lshortfile)

	Warning = log.New(warningHandle,
		"WARNING: ",
		log.Ldate | log.Ltime | log.Lshortfile)

	Error = log.New(errorHandle,
		"ERROR: ",
		log.Ldate | log.Ltime | log.Lshortfile)
}

func init() {
	initLog(os.Stdout, os.Stdout, os.Stdout, os.Stderr)
}

func SendClientCreatedOKResult(w http.ResponseWriter, request *http.Request, message string) {
	SendClientCreatedJsonStringResult(w, request, fmt.Sprintf("{\"message\":\"%s\"}", message))
}

func SendClientCreatedOKObject(w http.ResponseWriter, request *http.Request, obj interface{}) {
	response, err := json.Marshal(obj)
	if err != nil {
		SendClientErrorInternalServerErrorResult(w, request, err)
	} else {
		SendClientCreatedJsonStringResult(w, request, string(response))
	}
}

func SendClientOKObject(w http.ResponseWriter, request *http.Request, obj interface{}) {
	response, err := json.MarshalIndent(obj,"","   ")
	if err != nil {
		SendClientErrorInternalServerErrorResult(w, request, err)
	} else {
		SendClientOKJsonResult(w, request, string(response))
	}
}

func SendClientCreatedJsonStringResult(w http.ResponseWriter, request *http.Request, message string) {
	w.WriteHeader(http.StatusCreated)
	w.Header().Set("Content-Type", "application/json")
	io.WriteString(w, message)
}

func SendClientOKJsonResult(w http.ResponseWriter, request *http.Request, message string) {
	w.WriteHeader(http.StatusOK)
	w.Header().Set("Content-Type", "application/json")
	io.WriteString(w, message)
}

func SendClientOKMessageResult(w http.ResponseWriter, request *http.Request, message string) {
	SendClientOKObject(w, request, map[string]string{"response":"ok","message":message})
}

func SendClientErrorBadRequestError(w http.ResponseWriter, request *http.Request, error error) {
	Info.Println("BAD Request:[" + request.Method + "]{" + request.URL.Path + "}?" + request.URL.RawQuery )
	SendClientJsonObject(w, request, http.StatusBadRequest,  map[string]string{"response":"ok","message":error.Error()})
}

func SendClientErrorBadRequestMessage(w http.ResponseWriter, request *http.Request, message string) {
	SendClientJsonObject(w, request, http.StatusBadRequest,  map[string]string{"response":"ok","message":message})
}

func SendClientErrorUnauthorizedResult(w http.ResponseWriter, request *http.Request, error_message string) {
	SendClientJsonObject(w, request, http.StatusUnauthorized,  map[string]string{"response":"ok","message":error_message})
}

func SendClientErrorNotAcceptableResult(w http.ResponseWriter, request *http.Request, error_message string) {
	SendClientJsonObject(w, request, http.StatusNotAcceptable,  map[string]string{"response":"ok","message":error_message})
}

func SendClientErrorNotFoundResult(w http.ResponseWriter, request *http.Request, message string) {
	SendClientJsonObject(w, request, http.StatusNotFound, message)
}

// An unexpceted error
func SendClientErrorInternalServerErrorResult(w http.ResponseWriter, request *http.Request, error_message error) {
	//err := errors.Wrap(error_message, 1)
	//log.Println("Unexpected Error: Request:[" + request.Method + "]{" + request.URL.Path + "}?" + request.URL.RawQuery )
	//log.Println(err.ErrorStack())
	SendClientJsonObject(w, request, http.StatusInternalServerError, error_message.Error())
}

func sendClientErrorEmptyBodyResult(w http.ResponseWriter, request *http.Request, http_code int) {
	Info.Printf("ERROR EMPTY BODY RESONSE: %d\n", http_code)
	w.WriteHeader(http_code)
	w.Header().Set("Content-Type", "application/json")
}

func SendClientJsonObject(w http.ResponseWriter, request *http.Request, http_code int, obj interface{}) {
    w.Header().Set("Content-Type", "application/json")
    if error_object, is_error :=  obj.(error); is_error {
        // Might be {"Value":"string","Type":{},"Offset":10} which describes the json decoding error encountered
        if response, new_object_err := json.Marshal(map[string]string{"error":error_object.Error()});new_object_err != nil {
            w.WriteHeader(500)
            w.Write(response)
        } else {
            w.WriteHeader(http_code)
            w.Write(response)
        }
    }else{
        if response, new_object_err := json.Marshal(obj);new_object_err != nil {
            w.WriteHeader(500)
            w.Write(response)
        } else {
            w.WriteHeader(http_code)
            w.Write(response)
        }
    }
}

func NewHttpAPIError( error_code int, message string ) error{
	return &HttpAPIError{error_code,message,nil}
}
func NewHttpAPIErrorBadRequest( message string ) error {
	return &HttpAPIError{http.StatusBadRequest,message,nil}
}
func NewHttpAPIErrorForbidden( message string ) error {
	return &HttpAPIError{http.StatusForbidden,message,nil}
}
func NewHttpAPIErrorNotAcceptable( message string ) error {
	return &HttpAPIError{http.StatusNotAcceptable,message,nil}
}
func NewHttpAPIErrorUnauthorised( message string ) error {
	return &HttpAPIError{http.StatusUnauthorized,message,nil}
}
func NewHttpAPIErrorNotFound( message string ) error {
	return &HttpAPIError{http.StatusNotFound,message,nil}
}

func NewHttpAPIInternalErrorMessage( error string) error{
	return &HttpAPIError{http.StatusInternalServerError,error,nil}
}

func NewHttpAPIInternalError( error error ) error{
	return &HttpAPIError{http.StatusInternalServerError,"",error}
}

type HttpAPIError struct {
	ErrorCode int `json:"error_code"`
	ErrorMessage string `json:"error_message"`
	ErrorObject error `json:"error"`
}

type HttpAPIResponse struct {
	Message string `json:"message"`
}

func (e HttpAPIError) Error() string {
	return fmt.Sprintf("%s (%d)", e.ErrorMessage, e.ErrorCode)
}

func CanHaveGetInt(w http.ResponseWriter, r *http.Request, param string) (int, bool, bool) {
	menu_item_id_s := r.URL.Query().Get(param)
	if len(menu_item_id_s) == 0 {
		return 0, false, true
	}else {
		group_id, group_conv_err := strconv.Atoi(menu_item_id_s)
		if group_conv_err != nil {
			SendClientErrorBadRequestMessage(w, r, "Illegal " + param)
			return 0, true, false
		}
		return group_id, true, true
	}
}

func MustHaveGetInt(w http.ResponseWriter, r *http.Request, param string) (int64, bool) {
	menu_item_id_s := r.URL.Query().Get(param)

    if len(menu_item_id_s)==0 {
        vars := mux.Vars(r)
        menu_item_id_s = vars[param]
    }

	if len(menu_item_id_s) == 0 {
		SendClientErrorBadRequestMessage(w, r, "Missing " + param)
		return 0, false
	}else {
		group_id, group_conv_err := strconv.ParseInt(menu_item_id_s,10,0)
		if group_conv_err != nil {
			SendClientErrorBadRequestMessage(w, r, "Illegal " + param)
			return 0, false
		} else if group_id == 0 {
			SendClientErrorBadRequestMessage(w, r, "Illegal " + param)
			return 0, false
		}
		return group_id, true
	}
}

func MightHaveGetInt(r *http.Request, param string) (int64, bool, error) {
	menu_item_id_s := r.URL.Query().Get(param)

    if len(menu_item_id_s)==0 {
        vars := mux.Vars(r)
        menu_item_id_s = vars[param]
    }

	if len(menu_item_id_s) == 0 {
		return 0, false, nil
	}else {
		group_id, group_conv_err := strconv.ParseInt(menu_item_id_s,10,0)
		if group_conv_err != nil {
			return 0, true, NewHttpAPIErrorBadRequest("Illegal " + param)
		}
		return group_id, true, nil
	}
}

func MustHaveGetString(w http.ResponseWriter, r *http.Request, param string) (string, bool) {
	menu_item_id_s := r.URL.Query().Get(param)
	if len(menu_item_id_s) == 0 {
        vars := mux.Vars(r)
        menu_item_id_s = vars[param]

		if len(menu_item_id_s) == 0 {
			SendClientErrorBadRequestMessage(w, r, "Missing " + param)
			return "", false
		}
	}
	return menu_item_id_s, true
}

func MightHaveGetString(r *http.Request, param string) (string, bool) {
	menu_item_id_s := r.URL.Query().Get(param)

    if len(menu_item_id_s)==0 {
        vars := mux.Vars(r)
        menu_item_id_s = vars[param]
    }

	if len(menu_item_id_s) == 0 {
		return "", false
	}else {
		return menu_item_id_s, true
	}
}

func MightHaveGetCSVInts(r *http.Request, param string) ([]int64, bool, error) {
        parts := make([]int64,0)
        if p, present := MightHaveGetString(r,param);present{
                split := strings.Split(p,",")
                for _, spl := range split{
                        if group_id, group_conv_err := strconv.ParseInt(spl, 10, 0);group_conv_err != nil {
                                return []int64{}, true, NewHttpAPIErrorBadRequest("Illegal integer: " + spl)
                        }else {
                                parts = append(parts, group_id)
                        }
                }
                return parts, true, nil
        }else{
                return parts, false, nil
        }
}


func SendClientHttpError(w http.ResponseWriter, request *http.Request, e error ) {
    w.Header().Set("Content-Type", "application/json")
    error_code := http.StatusInternalServerError
    message:=""
    if error_object, is_error :=  e.(HttpAPIError); is_error {
        error_code = error_object.ErrorCode
        message = error_object.ErrorMessage
    }else{
        message = e.Error()
    }
    if response, new_object_err := json.Marshal(map[string]string{"error":message});new_object_err != nil {
        w.WriteHeader(500)
        w.Write([]byte("Unknown error"))
    } else {
        w.WriteHeader(error_code)
        w.Write(response)
    }
}


var DefaultOffset = 0
var DefaultLimit = 30

func ExtractOffsetLimit(r *http.Request) (int, int, int, int) {
    offset_s := r.URL.Query().Get("offset")
    limit_s := r.URL.Query().Get("limit")
    if len(limit_s) == 0 {
        limit_s = strconv.Itoa(DefaultLimit)
    }
    limit, limiterr := strconv.Atoi(limit_s)
    if limiterr != nil {
        limit = DefaultLimit
    }
    if len(offset_s) == 0 {
        offset_s = "0"
    }
    offset, offseterr := strconv.Atoi(offset_s)
    if offseterr != nil {
        offset = DefaultOffset
    }
    return offset, limit, 0, 0
}
